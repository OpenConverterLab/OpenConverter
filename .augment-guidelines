# OpenConverter - Augment Guidelines

## Project Overview

OpenConverter is a multimedia conversion application built on **FFmpeg**, **Qt**, and **BMF** frameworks. It provides simple and user-friendly tools to convert, edit, and process audio and video files with both GUI and CLI support.

**Key Technologies:**
- **FFmpeg**: Core multimedia processing library
- **Qt Framework**: Cross-platform GUI framework (Qt 5.14.2+)
- **BMF Framework**: Advanced multimedia processing framework (optional)
- **C/C++**: Primary programming languages
- **CMake**: Build system

**Main Features:**
1. Video/audio codec conversion (H.264, H.265, AAC, AC3, etc.)
2. Lossless multimedia remuxing (container format changes without re-encoding)
3. Media file information display (resolution, codec, bitrate, etc.)
4. Image compression with format/quality control
5. Audio extraction from video files
6. Video cutting with precise time selection
7. **Batch processing** with queue management for multiple files
8. Runtime switching of transcoding cores (FFmpeg API, FFTool, BMF)
9. Smooth progress tracking with accurate time estimation
10. Both GUI and CLI interfaces

## Project Structure

```
OpenConverter/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.cpp                 # Entry point (CLI + GUI)
â”‚   â”œâ”€â”€ CMakeLists.txt           # Build configuration
â”‚   â”œâ”€â”€ builder/                 # GUI pages and page-specific logic
â”‚   â”‚   â”œâ”€â”€ include/             # Header files for pages
â”‚   â”‚   â””â”€â”€ src/                 # Implementation files for pages
â”‚   â”œâ”€â”€ component/               # Reusable UI widgets (12 widgets)
â”‚   â”‚   â”œâ”€â”€ include/             # Widget headers
â”‚   â”‚   â””â”€â”€ src/                 # Widget implementations
â”‚   â”œâ”€â”€ common/                  # Shared utilities and data structures
â”‚   â”‚   â”œâ”€â”€ include/             # Common headers
â”‚   â”‚   â””â”€â”€ src/                 # Common implementations
â”‚   â”œâ”€â”€ engine/                  # Conversion engine
â”‚   â”‚   â”œâ”€â”€ include/             # Engine headers
â”‚   â”‚   â””â”€â”€ src/                 # Engine implementations
â”‚   â”œâ”€â”€ transcoder/              # Transcoding backends
â”‚   â”‚   â”œâ”€â”€ include/             # Transcoder headers
â”‚   â”‚   â””â”€â”€ src/                 # Transcoder implementations
â”‚   â”œâ”€â”€ resources/               # Qt resources (UI files, translations)
â”‚   â””â”€â”€ tests/                   # Unit tests
â”œâ”€â”€ doc/                         # Documentation
â”œâ”€â”€ img/                         # Images for README
â”œâ”€â”€ tool/                        # Development tools (formatting, testing)
â”œâ”€â”€ build/                       # Build output directory
â””â”€â”€ README.md                    # Project documentation
```

### Directory Responsibilities

- **`src/builder/`**: Qt-based GUI pages and page-specific logic (BasePage, *Page classes, batch system)
- **`src/component/`**: Reusable UI widgets (12 widgets: file selectors, progress bars, encoding parameter widgets)
- **`src/common/`**: Shared data structures (EncodeParameter, ProcessParameter, Info, etc.)
- **`src/engine/`**: Conversion orchestration (Converter class)
- **`src/transcoder/`**: Backend implementations (FFmpeg, FFTool, BMF)
- **`src/resources/`**: Qt UI files (.ui), translations (.ts, .qm), resource files (.qrc)

## Architecture

### Core Components

1. **Converter** (`src/engine/`)
   - Orchestrates the conversion process
   - Manages transcoder selection and initialization
   - Coordinates between parameters and transcoder backends

2. **Transcoder** (`src/transcoder/`)
   - Abstract base class for transcoding backends
   - Implementations: TranscoderFFmpeg, TranscoderFFTool, TranscoderBMF
   - Handles actual media processing (decode, encode, filter, mux)

3. **EncodeParameter** (`src/common/`)
   - Stores encoding settings (codec, bitrate, resolution, pixel format, etc.)
   - Used by all transcoding operations

4. **ProcessParameter** (`src/common/`)
   - Manages progress tracking and observer notifications
   - Implements observer pattern for UI updates

5. **Info** (`src/common/`)
   - Extracts and stores media file information
   - Uses FFmpeg to probe media files

6. **GUI Pages** (`src/builder/`)
   - BasePage: Abstract base class for all pages
   - InfoViewPage: Display media information
   - CompressPicturePage: Image compression
   - ExtractAudioPage: Extract audio from video
   - CutVideoPage: Cut video with time selection
   - RemuxPage: Change container format without re-encoding
   - TranscodePage: Full transcoding with codec/quality control

7. **Batch Processing System** (`src/builder/`)
   - BatchQueue: Manages queue of batch items for processing
   - BatchItem: Represents a single file in the batch queue
   - BatchQueueDialog: UI for monitoring batch processing progress
   - BatchFileDialog: Dialog for selecting multiple files with visual filter tags
   - BatchModeHelper: Coordinates between single file and batch modes

8. **Reusable UI Components** (`src/component/`)
   - **Encoding Parameter Widgets** (6 widgets):
     - ResolutionWidget: Width x Height selection with "auto" support
     - PixelFormatWidget: Pixel format selection with "auto" option
     - BitrateWidget: Bitrate selection with "auto" support
     - QualityWidget: Quality/qscale selection for image and video encoding
     - CodecSelectorWidget: Codec selection with "auto" and "copy" options
     - FormatSelectorWidget: Output format selection for video, audio, and image
   - **UI Infrastructure Widgets** (6 widgets):
     - FileSelectorWidget: Unified file selection (input/output, single/batch)
     - ProgressWidget: Progress bar + label for conversion tracking
     - FilterTagWidget: Visual tag-based file filter management
     - BatchInputWidget: Batch input file selection with directory support
     - BatchOutputWidget: Batch output configuration (directory, suffix, naming)
     - SimpleVideoPlayer: FFmpeg-based video player widget
   - **See**: `doc/COMPONENT_DIRECTORY.md` for detailed API documentation

### Design Patterns

- **Observer Pattern**: ProcessParameter notifies observers (UI) of progress updates
- **Strategy Pattern**: Transcoder backends (FFmpeg, FFTool, BMF) are interchangeable
- **Factory Pattern**: Converter creates appropriate transcoder based on selection
- **Page Pattern**: GUI uses page-based navigation with BasePage abstraction

## Coding Style

### Naming Conventions

**CRITICAL: Different naming conventions for different directories!**

#### For `src/common/`, `src/engine/`, `src/builder/`, `src/component/`:
- **Functions/Methods**: `PascalCase` (e.g., `SetTranscoder`, `GetVideoCodec`, `OnButtonClicked`)
- **Classes**: `PascalCase` (e.g., `Converter`, `EncodeParameter`, `BasePage`)
- **Member variables**: `camelCase` (e.g., `videoCodec`, `processParameter`, `inputFilePath`)
- **Local variables**: `camelCase` (e.g., `filePath`, `codecName`, `frameCount`)

#### For `src/transcoder/`:
- **Functions/Methods**: `snake_case` (e.g., `transcode`, `get_video_codec`, `set_audio_bitrate`)
- **Classes**: `PascalCase` (e.g., `Transcoder`, `TranscoderFFmpeg`)
- **Member variables**: `camelCase` or `snake_case` (be consistent within file)
- **Local variables**: `snake_case` (e.g., `input_path`, `codec_name`, `frame_count`)

### Code Formatting

- **Indentation**: 4 spaces (no tabs)
- **Line length**: Prefer â‰¤100 characters, max 120 characters
- **Braces**: Opening brace on same line for functions/classes
  ```cpp
  void MyFunction() {
      // code
  }
  ```
- **Pointer/Reference**: Attach to type, not variable
  ```cpp
  int *ptr;        // Correct
  int* ptr;        // Also acceptable
  int * ptr;       // Avoid
  ```
- **Whitespace**: No trailing whitespace, single newline at end of file

### File Headers

All source files (doesn't inlcude FFmpeg code) should include Apache 2.0 license header:
```cpp
/*
 * Copyright 2025 Jack Lau
 * Email: jacklau1222gm@gmail.com
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
```

**Note**: `src/transcoder/` (use FFmpeg code) should include LGPL 2.1 license (check existing files for header format)

### Qt-Specific Guidelines

1. **Signals and Slots**:
   - Signal names: `PascalCase` without prefix (e.g., `PositionChanged`, `DurationChanged`)
   - Slot names: `On` + `PascalCase` (e.g., `OnButtonClicked`, `OnPositionChanged`)

2. **Memory Management**:
   - Use Qt parent-child ownership when possible
   - Widgets with parent are automatically deleted
   - Use `deleteLater()` for QObject deletion in event loop

3. **Threading**:
   - Long operations MUST run in separate threads (use `QThread::create()`)
   - UI updates MUST use `QMetaObject::invokeMethod()` with `Qt::QueuedConnection`
   - Never block the main/UI thread

4. **Includes**:
   - Qt headers: `<QWidget>`, `<QString>`, etc.
   - Project headers: Use relative paths `"../include/header.h"`
   - FFmpeg headers: Wrap in `extern "C" { }`

### FFmpeg-Specific Guidelines

1. **Error Handling**:
   - Functions return `int` (FFmpeg error codes), not `bool`
   - Return `0` on success, negative on error (e.g., `AVERROR(ENOMEM)`, `AVERROR_DECODER_NOT_FOUND`)
   - **Code Style**: Combine assignment and comparison in if statements
     ```cpp
     // CORRECT
     if ((ret = avcodec_open2(ctx, codec, NULL)) < 0) {
         print_error("Failed to open codec", ret);
         return ret;
     }

     // AVOID
     ret = avcodec_open2(ctx, codec, NULL);
     if (ret < 0) {
         print_error("Failed to open codec", ret);
         return ret;
     }
     ```
   - **Multiple conditions**: Assignment in condition works with multiple checks
     ```cpp
     if ((ret = avcodec_receive_packet(ctx, pkt)) == AVERROR(EAGAIN) || ret == AVERROR_EOF) {
         ret = 0;
         goto end;
     }
     ```

2. **Memory Management**:
   - Always free FFmpeg structures: `avformat_close_input()`, `avcodec_free_context()`, `av_frame_free()`, etc.
   - Use `goto end` pattern for cleanup in error paths

3. **Time Handling**:
   - Use stream `time_base` for accurate timestamp conversion
   - Use `av_rescale_q()` for time base conversion

4. **Threading**:
   - FFmpeg operations are not thread-safe
   - Use mutex locks when accessing FFmpeg contexts from multiple threads

## Development Workflow

### Building the Project

```bash
# Create build directory
mkdir build && cd build

# Configure with CMake
cmake ../src -DENABLE_GUI=ON

# Build
make -j4

# Run
./OpenConverter              # GUI mode
./OpenConverter --help       # CLI mode
```

### Translation Workflow

OpenConverter uses Qt Linguist tools for internationalization (i18n). Translation files are located in `src/resources/`.

**Update translations after code changes:**
```bash
# 1. Extract translatable strings from source code (updates .ts file)
cd src
lupdate -recursive builder/ component/ -ts resources/lang_chinese.ts

# 2. Manually edit translations in resources/lang_chinese.ts
#    - Remove type="unfinished" attributes
#    - Add Chinese translations for new strings

# 3. Compile .ts to binary .qm file (required for runtime)
lrelease resources/lang_chinese.ts -qm resources/lang_chinese.qm
```

**Important Notes:**
- **Always run `lupdate`** after adding/modifying `tr()` calls in source code
- **Always run `lrelease`** after editing `.ts` files to update the `.qm` binary
- **Store inline QLabel pointers** as member variables so they can be retranslated in `RetranslateUi()`
- **Never create inline labels** like `new QLabel(tr("Text"), this)` - always store them for runtime translation support

**Translation Pattern:**
```cpp
// In header (.h):
QLabel *myLabel;

// In SetupUI():
myLabel = new QLabel(tr("My Label:"), this);
layout->addWidget(myLabel, 0, 0);

// In RetranslateUi():
myLabel->setText(tr("My Label:"));
```

### Adding a New GUI Page

1. Create header in `src/builder/include/your_page.h`
2. Create implementation in `src/builder/src/your_page.cpp`
3. Inherit from `BasePage`
4. Implement required virtual methods: `GetPageTitle()`, `OnPageActivated()`, `OnPageDeactivated()`
5. Add to `CMakeLists.txt` in `GUI_SOURCES` and `GUI_HEADERS`
6. Register in `OpenConverter::InitializePages()`
7. Add navigation button in UI file

### Adding a New Transcoder Backend

1. Create header in `src/transcoder/include/transcoder_yourname.h`
2. Create implementation in `src/transcoder/src/transcoder_yourname.cpp`
3. Inherit from `Transcoder` base class
4. Implement `transcode(input_path, output_path)` method
5. Add to `Converter::set_transcoder()` switch statement
6. Update CMakeLists.txt with conditional compilation flags

### Code Quality Tools

**Whitespace Cleanup:**
```bash
./tool/fix_whitespace.sh
```
- Removes trailing whitespace from all lines
- Ensures exactly one newline at end of file
- Processes all staged C++ files (.cpp, .h, .hpp, .cc, .cxx)
- **Does NOT auto-stage** - you must manually review and add changes with `git add`

## Testing

- Unit tests in `src/tests/`
- Use Google Test framework (if available)
- Test transcoder backends independently
- Test GUI pages with sample media files

## Common Pitfalls

1. **Mixing naming conventions**: Remember `PascalCase` for builder/common/engine, `snake_case` for transcoder
2. **Blocking UI thread**: Always use `QThread` for long operations
3. **Memory leaks**: Always free FFmpeg structures and Qt objects without parents
4. **Incorrect time base**: Use stream-specific time base, not `AV_TIME_BASE` for seeking
5. **Missing error checks**: Always check FFmpeg function return values

## GUI Architecture Details

### Page-Based Navigation System

The GUI uses a **stacked widget** approach with page-based navigation:

1. **OpenConverter** (Main Window)
   - Contains `QStackedWidget` for page switching
   - Manages `QButtonGroup` for navigation buttons
   - Handles page lifecycle (activation/deactivation)

2. **BasePage** (Abstract Base Class)
   - All pages inherit from `BasePage`
   - Virtual methods: `OnPageActivated()`, `OnPageDeactivated()`, `GetPageTitle()`
   - Provides consistent interface for page management

3. **SharedData** (Singleton Pattern)
   - Shares file paths between pages
   - Auto-generates output paths with pattern: `input_path-oc-operation.ext`
   - Prevents redundant file selection across pages

### Common UI Patterns

#### Standard Page Layout
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Top Section: Input File Selection  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Middle Section: Operation-Specific â”‚
â”‚ (Player, Settings, Preview, etc.)  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Bottom Section: Output & Action    â”‚
â”‚ (Output path, Convert/Cut button)  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Progress Section (hidden by default)â”‚
â”‚ (Progress bar, time remaining)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Threading Pattern for Long Operations
```cpp
// Standard pattern used in all conversion pages
void SomePage::OnConvertClicked() {
    // 1. Validate inputs
    if (!ValidateInputs()) return;

    // 2. Create parameters
    EncodeParameter *encodeParam = new EncodeParameter();
    ProcessParameter *processParam = new ProcessParameter();
    // ... configure parameters

    // 3. Show progress UI
    progressBar->setVisible(true);
    convertButton->setEnabled(false);

    // 4. Run conversion in separate thread
    QThread *thread = QThread::create([this, encodeParam, processParam]() {
        Converter converter;
        bool success = converter.Convert(encodeParam, processParam);

        // 5. Update UI on main thread
        QMetaObject::invokeMethod(this, [this, success]() {
            OnConversionFinished(success);
        }, Qt::QueuedConnection);

        delete encodeParam;
        delete processParam;
    });

    connect(thread, &QThread::finished, thread, &QThread::deleteLater);
    thread->start();
}
```

### Custom Widgets

#### SimpleVideoPlayer
- **Purpose**: FFmpeg-based video player for Cut Video page
- **Base Class**: `QLabel` (displays frames as QPixmap)
- **Key Features**:
  - Direct FFmpeg decoding (no Qt Multimedia dependency)
  - Supports all FFmpeg codecs
  - Real-time playback at ~30 fps
  - Accurate seeking with stream time base
  - Thread-safe with QMutex

**Usage Example**:
```cpp
SimpleVideoPlayer *player = new SimpleVideoPlayer(parent);
player->LoadVideo("/path/to/video.mp4");
player->Play();
player->Seek(5000); // Seek to 5 seconds
```

#### FileSelectorWidget
- **Purpose**: Unified file selection widget supporting both single and batch modes
- **Key Features**:
  - Browse button for single file selection
  - Batch button for multiple file selection
  - Automatic mode switching
  - Drag-and-drop support
  - File filter management

**Usage Example**:
```cpp
FileSelectorWidget *selector = new FileSelectorWidget(
    tr("Input File"),
    FileSelectorWidget::InputFile,
    tr("Select a media file..."),
    tr("Media Files (*.mp4 *.avi);;All Files (*.*)"),
    tr("Select Media File"),
    parent
);
connect(selector, &FileSelectorWidget::FileSelected, this, &Page::OnFileSelected);
connect(selector, &FileSelectorWidget::BatchFilesSelected, this, &Page::OnBatchFilesSelected);
```

#### FilterTagWidget
- **Purpose**: Visual tag-based widget for managing file filters
- **Key Features**:
  - Visual tags for each file extension (e.g., `.mp4`, `.avi`)
  - Individual delete button (Ã—) for each tag
  - Add button to add new extensions
  - Auto-normalization of extensions (e.g., `mp4` â†’ `*.mp4`)
  - Duplicate prevention
  - Horizontal scrolling for many tags

**Usage Example**:
```cpp
FilterTagWidget *filterWidget = new FilterTagWidget(parent);
filterWidget->SetFilter("*.mp4,*.avi,*.mkv");
connect(filterWidget, &FilterTagWidget::FilterChanged, this, [](const QString &filter) {
    qDebug() << "New filter:" << filter;
});
```

## Implementation Best Practices

### 1. Non-Blocking UI Operations

**Problem**: FFmpeg operations (opening files, seeking, decoding) can block the UI thread.

**Solution**:
- Limit FFmpeg analysis time: `formatCtx->max_analyze_duration = 5 * AV_TIME_BASE`
- Defer heavy operations: Use `QTimer::singleShot(0, ...)` for deferred execution
- Use worker threads for long operations (conversion, cutting, etc.)

### 2. Progress Reporting

**Pattern**: Observer pattern with thread-safe UI updates

```cpp
// In transcoder (worker thread)
void Transcoder::send_process_parameter(int64_t current, int64_t total) {
    double progress = (current * 100.0) / total;
    processParameter->notify_observers_progress(progress);
}

// In GUI page (implements ProcessObserver)
void SomePage::on_process_update(double progress) {
    QMetaObject::invokeMethod(this, [this, progress]() {
        progressBar->setValue(static_cast<int>(progress));
    }, Qt::QueuedConnection);
}
```

### 3. Time Base Conversion

**Always use stream-specific time base for accurate seeking**:

```cpp
// CORRECT: Use stream time base
AVStream *stream = formatCtx->streams[streamIndex];
int64_t timestamp = av_rescale_q(positionMs, AVRational{1, 1000}, stream->time_base);
av_seek_frame(formatCtx, streamIndex, timestamp, AVSEEK_FLAG_BACKWARD);

// WRONG: Using AV_TIME_BASE for seeking (inaccurate)
int64_t timestamp = (positionMs * AV_TIME_BASE) / 1000;
av_seek_frame(formatCtx, -1, timestamp, AVSEEK_FLAG_BACKWARD);
```

### 4. Memory Management Checklist

**FFmpeg Resources** (must be freed manually):
- `avformat_close_input(&formatCtx)`
- `avcodec_free_context(&codecCtx)`
- `av_frame_free(&frame)`
- `av_packet_free(&packet)`
- `sws_freeContext(swsCtx)`
- `av_free(buffer)`

**Qt Resources** (auto-deleted if parent is set):
- Widgets with parent: Auto-deleted
- Widgets without parent: Must call `delete` or `deleteLater()`
- QThread: Connect `finished()` signal to `deleteLater()`

### 5. Error Handling Pattern

```cpp
// FFmpeg operations
if (avformat_open_input(&formatCtx, path, nullptr, nullptr) < 0) {
    qDebug() << "Failed to open file:" << path;
    // Clean up and return
    return false;
}

// Qt operations
if (!file.open(QIODevice::ReadOnly)) {
    QMessageBox::warning(this, "Error", "Failed to open file");
    return;
}
```

## Special Considerations

### Video Player Implementation

The `SimpleVideoPlayer` widget demonstrates several advanced techniques:

1. **Deferred Frame Decoding**: First frame decode happens asynchronously to avoid blocking
2. **Accurate Seeking**: Decodes frames sequentially after seeking to reach exact position
3. **Mutex Protection**: All FFmpeg operations protected by QMutex for thread safety
4. **Signal-Based Updates**: Emits `PositionChanged` and `DurationChanged` signals

### Transcoder Implementations

- **TranscoderFFmpeg**: Uses FFmpeg API directly (most flexible)
- **TranscoderFFTool**: Wraps FFmpeg command-line tool (simpler but less control)
- **TranscoderBMF**: Uses BMF framework (advanced features, optional dependency)

All transcoders implement the same interface, allowing runtime switching.

## Resources

- FFmpeg Documentation: https://ffmpeg.org/documentation.html
- Qt Documentation: https://doc.qt.io/
- BMF Framework: https://babitmf.github.io
- Learn FFmpeg the Hard Way: https://github.com/TSGU-OSC/Learn_FFmpeg_the_Hard_Way

## Contact

- Author: Jack Lau
- Email: jacklau1222gm@gmail.com
- License: Apache 2.0 (most files), LGPL 2.1 (transcoder directory)

---

## ðŸ“ Note for AI Assistant

**ALWAYS UPDATE THIS FILE** when you learn new project conventions, patterns, or best practices.

Update after: refactoring, discovering undocumented patterns, fixing bugs, adding features, or code reviews.

Keep it concise with clear examples.
